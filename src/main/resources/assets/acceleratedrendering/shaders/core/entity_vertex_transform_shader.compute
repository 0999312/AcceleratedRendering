#version 460 core

struct Vertex {
    float x;
    float y;
    float z;
    int color;
    float u0;
    float v0;
    int uv1;
    int uv2;
    uint normal;
};

struct VaryingData {
    int mesh;
    int pose;
    int color;
    int light;
    int overlay;
};

struct Pose {
    mat4 transform;
    mat3 normal;
};

layout(local_size_x=1, local_size_y=1) in;

layout(binding=0, std430) buffer Data {
    Vertex vertices[];
};

layout(binding=1, std430) readonly buffer Poses {
    Pose poses[];
};

layout(binding=2, std430) readonly buffer Varyings {
    VaryingData varyings[];
};

layout(binding=3, std430) readonly buffer Mesh {
    Vertex meshVertices[];
};

void main() {
    int index = int(gl_GlobalInvocationID.x);
    VaryingData varyingData = varyings[index];

    int pose = varyingData.pose;
    int mesh = varyingData.mesh;

    if (pose < 0) {
        return;
    }

    Vertex refVertex = mesh != -1 ? meshVertices[mesh] : vertices[index];

    vec3 pos = vec3(refVertex.x, refVertex.y, refVertex.z);

    int normalZ = int((refVertex.normal >> 16) & 0xFFu);
    int normalY = int((refVertex.normal >> 8) & 0xFFu);
    int normalX = int((refVertex.normal >> 0) & 0xFFu);

    if (normalX > 127) normalX -= 256;
    if (normalY > 127) normalY -= 256;
    if (normalZ > 127) normalZ -= 256;

    vec3 normal = vec3(normalX / 127.0, normalY / 127.0, normalZ / 127.0);
    vec4 transformedPos = poses[pose].transform * vec4(pos, 1.0);
    vec3 transformedNormal = normalize(poses[pose].normal * normal);

    uint transformedNormalX = uint(int(clamp(transformedNormal.x, -1.0, 1.0) * 127.0) & 0xFF);
    uint transformedNormalY = uint(int(clamp(transformedNormal.y, -1.0, 1.0) * 127.0) & 0xFF);
    uint transformedNormalZ = uint(int(clamp(transformedNormal.z, -1.0, 1.0) * 127.0) & 0xFF);

    vertices[index].x = transformedPos.x;
    vertices[index].y = transformedPos.y;
    vertices[index].z = transformedPos.z;

    vertices[index].color = varyingData.color;

    vertices[index].u0 = refVertex.u0;
    vertices[index].v0 = refVertex.v0;

    vertices[index].uv1 = varyingData.overlay;
    vertices[index].uv2 = varyingData.light;

    vertices[index].normal = (transformedNormalZ << 16) | (transformedNormalY << 8) | (transformedNormalX << 0);
}